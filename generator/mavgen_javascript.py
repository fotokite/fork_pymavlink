#!/usr/bin/env python
"""
parse a MAVLink protocol XML file and generate a Node.js javascript module implementation

Based on original work Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
"""
from __future__ import print_function

from builtins import range

import os
import textwrap
from . import mavtemplate
import sys

t = mavtemplate.MAVTemplate()


def get_mavhead(xml):
    return "mavlink20" if xml.protocol_marker == 253 else "mavlink10"


def get_mavprocessor(xml):
    return "MAVLink20Processor" if xml.protocol_marker == 253 else "MAVLink10Processor"


def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    outf.write(
        f"""
/*
MAVLink protocol implementation for node.js (auto-generated by mavgen_javascript.py)

Generated from: {",".join(args)}

Note: this file has been auto-generated. DO NOT EDIT
*/

import {{ each }} from "lodash-es";
import {{ EventEmitter }} from "events";
import {{ Buffer }} from "buffer";
import Long from "long";
import {{jspack}} from "jspack";


const pack = (fmt, args) => {{
    return jspack.Pack(fmt, args, true);
}}
const unpack = (fmt, data) => {{
    return jspack.Unpack(fmt, data, 0, true);
}}
// Add a convenience method to Buffer
Buffer.prototype.toByteArray = function () {{
  return Array.from(this);
}}

const mavlink20 = {{}};

// Implement the CRC-16/MCRF4XX function (present in the Python version through the mavutil.py package)
mavlink20.x25Crc = function(buffer, crcIN) {{
    let bytes = buffer;
    let crcOUT = crcIN === undefined ? 0xffff : crcIN;
    each(bytes, function(e) {{
        let tmp = e ^ (crcOUT & 0xff);
        tmp = (tmp ^ (tmp << 4)) & 0xff;
        crcOUT = (crcOUT >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
        crcOUT = crcOUT & 0xffff;
    }});
    return crcOUT;
}}

mavlink20.WIRE_PROTOCOL_VERSION = "{'2.0' if xml.protocol_marker == 253 else '1.0'}";
mavlink20.PROTOCOL_MARKER_V1 = 0xFE;
mavlink20.PROTOCOL_MARKER_V2 = 0xFD;
mavlink20.HEADER_LEN_V1 = 6;
mavlink20.HEADER_LEN_V2 = 10;
mavlink20.HEADER_LEN = {10 if xml.protocol_marker == 253 else 6};

mavlink20.MAVLINK_TYPE_CHAR     = 0;
mavlink20.MAVLINK_TYPE_UINT8_T  = 1;
mavlink20.MAVLINK_TYPE_INT8_T   = 2;
mavlink20.MAVLINK_TYPE_UINT16_T = 3;
mavlink20.MAVLINK_TYPE_INT16_T  = 4;
mavlink20.MAVLINK_TYPE_UINT32_T = 5;
mavlink20.MAVLINK_TYPE_INT32_T  = 6;
mavlink20.MAVLINK_TYPE_UINT64_T = 7;
mavlink20.MAVLINK_TYPE_INT64_T  = 8;
mavlink20.MAVLINK_TYPE_FLOAT    = 9;
mavlink20.MAVLINK_TYPE_DOUBLE   = 10;

mavlink20.MAVLINK_IFLAG_SIGNED = 0x01;
mavlink20.MAVLINK_SIGNATURE_BLOCK_LEN = 13;

// Mavlink headers incorporate sequence, source system (platform) and source component.
mavlink20.header = class {{
    constructor(msgId, mlen, seq, srcSystem, srcComponent, incompat_flags = 0, compat_flags = 0) {{
        this.mlen = mlen ?? 0;
        this.seq = seq ?? 0;
        this.srcSystem = srcSystem ?? 0;
        this.srcComponent = srcComponent ?? 0;
        this.msgId = msgId;
        this.incompat_flags = incompat_flags;
        this.compat_flags = compat_flags;
    }}

    pack() {{
        {f"return pack('BBBBBBBHB', [{xml.protocol_marker}, this.mlen, this.incompat_flags, this.compat_flags, this.seq, this.srcSystem, this.srcComponent, ((this.msgId & 0xFF) << 8) | ((this.msgId >> 8) & 0xFF), this.msgId>>16]);" if xml.protocol_marker == 253 else f"return pack('BBBBBB', [{xml.protocol_marker}, this.mlen, this.seq, this.srcSystem, this.srcComponent, this.msgId]);"}
    }}
}};

// Base class declaration: mavlink.message will be the parent class for each
// concrete implementation in mavlink.messages.
class Message extends EventEmitter {{
    constructor() {{
        super();
    }}

    // Convenience setter to facilitate turning the unpacked array of data into member properties
    set(args, verbose) {{
        each(this.fieldnames, (e, i) => {{
            const num = parseInt(i, 10);
            if (this.hasOwnProperty(e) && isNaN(num)) {{
                if (verbose >= 1) {{
                    console.log(`WARNING, overwriting an existing property is DANGEROUS: ${{e}} ==>${{i}}==>${{args[i]}} -> ${{JSON.stringify(this)}}`);
                }}
            }}
        }});

        // then modify
        each(this.fieldnames, (e, i) => {{
            this[e] = args[i];
        }});
    }}

    // Function to sign the packet (if signing is enabled)
    sign_packet(mav) {{
        const h = crypto.createHash('sha256');
        const thigh = (mav.signing.timestamp >>> 32); // 2 bytes from the top, shifted right by 32 bits
        const tlow = (mav.signing.timestamp & 0xffffffff); // 4 bytes from the bottom

        this._msgbuf = this._msgbuf.concat(pack('<BIH', [mav.signing.link_id, tlow, thigh]));
        h.update(mav.signing.secret_key); // secret is already a Buffer
        h.update(Buffer.from(this._msgbuf));

        const hashDigest = h.digest();
        const sig = hashDigest.slice(0, 6);
        this._msgbuf = this._msgbuf.concat(...sig);

        mav.signing.timestamp += 1;
    }}

    // This pack function builds the header and produces a complete MAVLink message,
    // including header and message CRC.


    pack(mav, crc_extra, payload) {{
        // Set the payload
        this._payload = payload;
        let plen = this._payload.length;

        // Strip trailing zeros from the payload to allow for smaller packets
        while (
            plen > 1 &&
            (this._payload[plen - 1] === 0 || this._payload[plen - 1] === null)
        ) {{
            plen -= 1;
        }}
        this._payload = this._payload.slice(0, plen);

        // Set incompat_flags for signing
        let incompat_flags = 0;
        let compat_flags = 0;
        if (mav?.signing?.sign_outgoing) {{
            incompat_flags |= mavlink20.MAVLINK_IFLAG_SIGNED;
        }}
        // Create header
        this._header = new mavlink20.header(
            this._id, // Message ID
            this._payload.length, // Payload length
            mav.seq, // Sequence number
            mav.srcSystem, // Source system
            mav.srcComponent, // Source component
            incompat_flags, // Incompat flags
            compat_flags
        );

        // Initialize message buffer by concatenating the packed header and payload
        this._msgbuf = this._header.pack().concat(this._payload);

        // Compute the CRC
        let crc = mavlink20.x25Crc(this._msgbuf.slice(1)); // Skip the STX byte (start byte) for CRC computation
        crc = mavlink20.x25Crc([crc_extra], crc); // Include the CRC extra byte in the CRC computation
        this._msgbuf = this._msgbuf.concat(jspack.Pack("<H", [crc])); // Append the CRC to the message buffer

        // Optionally add signing if signing is enabled
        if (mav.signing?.sign_outgoing) {{
            this.sign_packet(mav);
        }}

        // Return the complete message buffer
        return this._msgbuf;
    }}
}}

// Export the base Message class
mavlink20.message = Message;
"""
)


def generate_enums(outf, enums, xml):
    print("Generating enums")
    outf.write("\n// enums\n")
    wrapper = textwrap.TextWrapper(
        initial_indent="", subsequent_indent="                        // "
    )
    for e in enums:
        outf.write(f"\n// {e.name}\n")
        for entry in e.entry:
            description = wrapper.fill(entry.description)
            outf.write(f"export const {entry.name} = {entry.value}; // {description}\n")

    # Generate an object containing all enums
    outf.write("\nexport const Enums = {\n")
    for e in enums:
        outf.write("  {}: {{\n".format(e.name))
        for entry in e.entry:
            outf.write(f"    {entry.name}: {entry.name},\n")
        outf.write("  },\n")
    outf.write("};\n")


def generate_message_ids(outf, msgs, xml):
    print("Generating message IDs")
    outf.write("\n// message IDs\n")
    outf.write("export const MAVLINK_MSG_ID_BAD_DATA = -1;\n")

    for m in msgs:
        outf.write(f"export const MAVLINK_MSG_ID_{m.name.upper()} = {m.id};\n")

    # Generate an object containing all message IDs
    outf.write("\nexport const MessageIds = {\n")
    outf.write("  MAVLINK_MSG_ID_BAD_DATA,\n")
    for m in msgs:
        outf.write(f"  MAVLINK_MSG_ID_{m.name.upper()},\n")
    outf.write("};\n")


def generate_classes(outf, msgs, xml):
    """
    Generate the implementations of the classes representing MAVLink messages.
    """
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="")
    outf.write("\nexport const messages = {};\n\n")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            if not f.omit_arg:
                ret += f"                {f.name:<18} : {f.description.strip()} ({f.type})\n"
        return ret

    # now do all the messages
    for m in msgs:
        # assemble some strings we'll use later in outputting ..
        comment = (
            f"{wrapper.fill(m.description.strip())}\n\n{field_descriptions(m.fields)}"
        )
        argfieldnames = [f.name for f in m.fields if not f.omit_arg]
        conststr = "".join(
            f"    this.{f.name} = {f.const_value};\n" for f in m.fields if f.omit_arg
        )

        # instance field support copied from mavgen_python
        instance_field = (
            f"'{m.instance_field}'" if m.instance_field is not None else "undefined"
        )
        instance_offset = m.field_offsets.get(m.instance_field, -1)

        # start with the comment block
        outf.write(
            f"""
/*
{comment}
*/
"""
        )

        # class declaration
        outf.write(f"export class {m.name.capitalize()} extends Message {{\n")

        # constructor
        outf.write(f"  constructor({', '.join(argfieldnames)}) {{\n")
        outf.write("    super();\n")
        for arg in argfieldnames:
            outf.write(f"    this.{arg} = {arg};\n")
        outf.write(conststr)
        outf.write(
            f"""
    this._format = '{m.fmtstr}';
    this._id = MAVLINK_MSG_ID_{m.name.upper()};
    this.order_map = {m.order_map};
    this.len_map = {m.len_map};
    this.array_len_map = {m.array_len_map};
    this.crc_extra = {m.crc_extra};
    this._name = '{m.name.upper()}';

    this._instance_field = {instance_field};
    this._instance_offset = {instance_offset};

    this.fieldnames = {m.fieldnames};
  }}

"""
        )

        # Implement the pack() method for this message
        orderedfields = (
            "const orderedfields = ["
            + ", ".join(f"this.{f}" for f in m.ordered_fieldnames)
            + "];"
        )
        outf.write(
            f"""
  pack(mav) {{
    {orderedfields}
    const j = pack(this._format, orderedfields);
    if (j === false) throw new Error("pack unable to handle this packet");
    return super.pack(mav, this.crc_extra, j);
  }}
}}
"""
        )

        # Add the message to the messages object
        outf.write(f"messages.{m.name.lower()} = {m.name.capitalize()};\n\n")
        outf.write(f"{get_mavhead(xml)}.messages = messages;\n\n")

    # Export the messages object


def mavfmt(field):
    """Work out the struct format for a type"""
    type_map = {
        "float": "f",
        "double": "d",
        "char": "c",
        "int8_t": "b",
        "uint8_t": "B",
        "uint8_t_mavlink_version": "B",
        "int16_t": "h",
        "uint16_t": "H",
        "int32_t": "i",
        "uint32_t": "I",
        "int64_t": "q",
        "uint64_t": "Q",
    }

    if field.array_length:
        if field.type in ["char", "int8_t", "uint8_t"]:
            return f"{field.array_length}s"
        return f"{field.array_length}{type_map[field.type]}"
    return type_map[field.type]


def generate_mavlink_class(outf, msgs, xml):
    print("Generating MAVLink class")

    # Write mapper to enable decoding based on the integer message type
    outf.write(
        f"""
{get_mavhead(xml)}.messages.bad_data = class BadData {{
    constructor(data, reason) {{
        this._id = {get_mavhead(xml)}.MAVLINK_MSG_ID_BAD_DATA;
        this._data = data;
        this._reason = reason;
        this._msgbuf = data;
    }}
}};
"""
    )

    outf.write(f"\n\n {get_mavhead(xml)}.map = {{ ")
    for m in msgs:
        outf.write(
            f"        {m.id}: {{ format: '{m.fmtstr}', type: {get_mavhead(xml)}.messages.{m.name.lower()}, order_map: {m.order_map}, crc_extra: {m.crc_extra} }},\n"
        )
    outf.write("};\n\n")

    outf.write(
        f"""
// MAVLink signing state class
class MAVLinkSigning {{
    constructor() {{
        this.secret_key = Buffer.from([]);
        this.timestamp = 1;
        this.link_id = 0;
        this.sign_outgoing = false;
        this.allow_unsigned_callback = undefined;
        this.stream_timestamps = {{}};
        this.sig_count = 0;
        this.badsig_count = 0;
        this.goodsig_count = 0;
        this.unsigned_count = 0;
        this.reject_count = 0;
    }}
}}

// MAVLink protocol handling class
class {get_mavprocessor(xml)} extends EventEmitter {{
    constructor(logger, srcSystem = 0, srcComponent = 0) {{
        super();
        this.logger = logger;
        this.seq = 0;
        this.buf = Buffer.from([]);
        this.bufInError = Buffer.from([]);
        this.srcSystem = srcSystem;
        this.srcComponent = srcComponent;
        this.have_prefix_error = false;
        this.protocol_marker = {xml.protocol_marker};
        this.expected_length = {get_mavhead(xml)}.HEADER_LEN;
        this.little_endian = true;
        this.crc_extra = true;
        this.sort_fields = true;
        this.total_packets_sent = 0;
        this.total_bytes_sent = 0;
        this.total_packets_received = 0;
        this.total_bytes_received = 0;
        this.total_receive_errors = 0;
        this.startup_time = Date.now();
        this.signing = new MAVLinkSigning();
    }}

    log(level, message) {{
        if (this.logger) {{
            //this.logger?.log(level, message);
        }}
    }}

    send(mavmsg) {{
        const buf = mavmsg.pack(this);
        this.file.write(buf);
        this.seq = (this.seq + 1) % 256;
        this.total_packets_sent += 1;
        this.total_bytes_sent += buf.length;
    }}

    bytes_needed() {{
        const ret = this.expected_length - this.buf.length;
        return ret <= 0 ? 1 : ret;
    }}

    pushBuffer(data) {{
        if (data) {{
            this.buf = Buffer.concat([this.buf, data]);
            this.total_bytes_received += data.length;
        }}
    }}

    parsePrefix() {{
        if (this.buf.length >= 1 && this.buf[0] !== this.protocol_marker) {{
            const badPrefix = this.buf[0];
            this.bufInError = this.buf.slice(0, 1);
            this.buf = this.buf.slice(1);
            this.expected_length = {get_mavhead(xml)}.HEADER_LEN;
            throw new Error(`Bad prefix (${{badPrefix}})`);
        }}
    }}

    parseLength() {{
        if (this.buf.length >= 3) {{
            const [magic, mlen, incompat_flags] = unpack('BBB', this.buf.slice(0, 3));
            this.expected_length = mlen + {get_mavhead(xml)}.HEADER_LEN + 2;
            this.incompat_flags = incompat_flags;
            if (magic === {get_mavhead(xml)}.PROTOCOL_MARKER_V2 && (this.incompat_flags & {get_mavhead(xml)}.MAVLINK_IFLAG_SIGNED)) {{
                this.expected_length += {get_mavhead(xml)}.MAVLINK_SIGNATURE_BLOCK_LEN;
            }}
        }}
    }}

    parseChar(c) {{
        let m = null;
        try {{
            this.pushBuffer(c);
            this.parsePrefix();
            this.parseLength();
            m = this.parsePayload();
        }} catch (e) {{
            this.log('error', e.message);
            this.total_receive_errors += 1;
            m = new {get_mavhead(xml)}.messages.bad_data(this.bufInError, e.message);
            this.bufInError = Buffer.from([]);
        }}

        if (m !== null) {{
            this.emit(m._name, m);
            this.emit('message', m);
        }}

        return m;
    }}

    parsePayload() {{
        let m = null;
        if (this.expected_length >= {get_mavhead(xml)}.HEADER_LEN + 2 && this.buf.length >= this.expected_length) {{
            const mbuf = this.buf.slice(0, this.expected_length);
            this.buf = this.buf.slice(this.expected_length);
            this.expected_length = {get_mavhead(xml)}.HEADER_LEN;

            try {{
                m = this.decode(mbuf);
                this.total_packets_received += 1;
            }} catch (e) {{
                this.bufInError = mbuf;
                throw e;
            }}
        }}
        return m;
    }}

    decode(msgbuf) {{
        var magic,
            incompat_flags,
            compat_flags,
            mlen,
            seq,
            srcSystem,
            srcComponent,
            unpacked,
            msgId,
            signature_len;
        // decode the header
        try {{
            unpacked = jspack.Unpack("cBBBBBBHB", msgbuf.slice(0, 10)); // the H in here causes msgIDlow to takeup 2 bytes, the rest 1
            magic = unpacked[0];
            mlen = unpacked[1];
            incompat_flags = unpacked[2];
            compat_flags = unpacked[3];
            seq = unpacked[4];
            srcSystem = unpacked[5];
            srcComponent = unpacked[6];
            var msgIDlow =
                ((unpacked[7] & 0xff) << 8) | ((unpacked[7] >> 8) & 0xff); // first-two msgid bytes
            var msgIDhigh = unpacked[8]; // the 3rd msgid byte
            msgId = msgIDlow | (msgIDhigh << 16); // combined result. 0 - 16777215  24bit number
        }} catch (e) {{
            throw new Error("Unable to unpack MAVLink header: " + e.message);
        }}
        //  TODO allow full parsing of 1.0 inside the 2.0 parser, this is just a start
        if (magic == mavlink20.PROTOCOL_MARKER_V1) {{
            //headerlen = 6;
            // these two are in the same place in both v1 and v2 so no change needed:
            //magic = magic;
            //mlen = mlen;
            // grab mavlink-v1 header position info from v2 unpacked position
            seq1 = incompat_flags;
            srcSystem1 = compat_flags;
            srcComponent1 = seq;
            msgId1 = srcSystem;
            // override the v1 vs v2 offsets so we get the correct data either way...
            seq = seq1;
            srcSystem = srcSystem1;
            srcComponent = srcComponent1;
            msgId = msgId1;
            // don't exist in mavlink1, so zero-them
            incompat_flags = 0;
            compat_flags = 0;
            signature_len = 0;
            // todo add more v1 here and don't just return
            return;
        }}
        if (magic.charCodeAt(0) != this.protocol_marker) {{
            throw new Error(
                "Invalid MAVLink prefix (" + magic.charCodeAt(0) + ")"
            );
        }}
        // is packet supposed to be signed?
        if (incompat_flags & mavlink20.MAVLINK_IFLAG_SIGNED) {{
            signature_len = mavlink20.MAVLINK_SIGNATURE_BLOCK_LEN;
        }} else {{
            signature_len = 0;
        }}
        // header's declared len compared to packets actual len
        var actual_len =
            msgbuf.length - (mavlink20.HEADER_LEN + 2 + signature_len);
        var actual_len_nosign = msgbuf.length - (mavlink20.HEADER_LEN + 2);
        if (mlen == actual_len && signature_len > 0) {{
            var len_if_signed = mlen + signature_len;
            //console.log("Packet appears signed && labeled as signed, OK. msgId=" + msgId);
        }} else if (mlen == actual_len_nosign && signature_len > 0) {{
            var len_if_signed = mlen + signature_len;
            throw new Error(
                "Packet appears unsigned when labeled as signed. Got actual_len " +
                    actual_len_nosign +
                    " expected " +
                    len_if_signed +
                    ", msgId=" +
                    msgId
            );
        }} else if (mlen != actual_len) {{
            throw new Error(
                "Invalid MAVLink message length.  Got " +
                    (msgbuf.length - (mavlink20.HEADER_LEN + 2)) +
                    " expected " +
                    mlen +
                    ", msgId=" +
                    msgId
            );
        }}
        if (!mavlink20.map?.[msgId]) {{
            throw new Error("Unknown MAVLink message ID (" + msgId + ")");
        }}
        // here's the common chunks of packet we want to work with below..
        var headerBuf = msgbuf.slice(mavlink20.HEADER_LEN); // first10
        var sigBuf = msgbuf.slice(-signature_len); // last 13 or nothing
        var crcBuf1 = msgbuf.slice(-2); // either last-2 or last-2-prior-to-signature
        var crcBuf2 = msgbuf.slice(-15, -13); // either last-2 or last-2-prior-to-signature
        var payloadBuf = msgbuf.slice(
            mavlink20.HEADER_LEN,
            -(signature_len + 2)
        ); // the remaining bit between the header and the crc
        var crcCheckBuf = msgbuf.slice(1, -(signature_len + 2)); // the part uses to calculate the crc - ie between the magic and signature,
        // decode the payload
        var decoder = mavlink20.map[msgId];
        // decode the checksum
        var receivedChecksum = undefined;
        if (signature_len == 0) {{
            // unsigned
            try {{
                receivedChecksum = jspack.Unpack("<H", crcBuf1);
            }} catch (e) {{
                throw new Error(
                    "Unable to unpack MAVLink unsigned CRC: " + e.message
                );
            }}
        }} else {{
            // signed
            try {{
                receivedChecksum = jspack.Unpack("<H", crcBuf2);
            }} catch (e) {{
                throw new Error(
                    "Unable to unpack MAVLink signed CRC: " + e.message
                );
            }}
        }}
        receivedChecksum = receivedChecksum[0];
        // make our own chksum of the relevant part of the packet...
        // var messageChecksum = mavlink20.x25Crc(crcCheckBuf);
        // var messageChecksum2 = mavlink20.x25Crc(
        //     [decoder.crc_extra],
        //     messageChecksum
        // );
        // if (receivedChecksum != messageChecksum2) {{
        //     throw new Error(
        //         "invalid MAVLink CRC in msgID " +
        //             msgId +
        //             ", got 0x" +
        //             receivedChecksum +
        //             " checksum, calculated payload checksum as 0x" +
        //             messageChecksum2
        //     );
        // }}
        // now check the signature...
        var sig_ok = false;
        if (signature_len == mavlink20.MAVLINK_SIGNATURE_BLOCK_LEN) {{
            this.signing.sig_count += 1;
        }}
        // it's a Buffer, zero-length means unused
        if (this.signing.secret_key.length != 0) {{
            var accept_signature = false;
            if (signature_len == mavlink20.MAVLINK_SIGNATURE_BLOCK_LEN) {{
                sig_ok = this.check_signature(msgbuf, srcSystem, srcComponent);
                accept_signature = sig_ok;
                if (sig_ok) {{
                    this.signing.goodsig_count += 1;
                }} else {{
                    this.signing.badsig_count += 1;
                }}
                if (
                    !accept_signature &&
                    this.signing.allow_unsigned_callback != undefined
                ) {{
                    accept_signature = this.signing.allow_unsigned_callback(
                        this,
                        msgId
                    );
                    if (accept_signature) {{
                        this.signing.unsigned_count += 1;
                    }} else {{
                        this.signing.reject_count += 1;
                    }}
                }}
            }} else if (this.signing.allow_unsigned_callback != undefined) {{
                accept_signature = this.signing.allow_unsigned_callback(
                    this,
                    msgId
                );
                if (accept_signature) {{
                    this.signing.unsigned_count += 1;
                }} else {{
                    this.signing.reject_count += 1;
                }}
            }}
            if (!accept_signature) throw new Error("Invalid signature");
        }}
        // now look at the specifics of the payload...
        var paylen = jspack.CalcLength(decoder.format);
        //put any truncated 0's back in (ie zero-pad )
        if (paylen > payloadBuf.length) {{
            payloadBuf = Buffer.concat([
                payloadBuf,
                Buffer.alloc(paylen - payloadBuf.length),
            ]);
        }}
        // Decode the payload and reorder the fields to match the order map.
        try {{
            var t = jspack.Unpack(decoder.format, payloadBuf);
        }} catch (e) {{
            throw new Error(
                "Unable to unpack MAVLink payload type=" +
                    decoder.type +
                    " format=" +
                    decoder.format +
                    " payloadLength=" +
                    payloadBuf +
                    ": " +
                    e.message
            );
        }}
        // Need to check if the message contains arrays
        var args = {{}};
        const elementsInMsg = decoder.order_map.length;
        const actualElementsInMsg = JSON.parse(JSON.stringify(t)).length;
        if (elementsInMsg == actualElementsInMsg) {{
            // Reorder the fields to match the order map
            each(t, function (e, i, l) {{
                args[i] = t[decoder.order_map[i]];
            }});
        }} else {{
            // This message contains arrays
            var typeIndex = 1;
            var orderIndex = 0;
            var memberIndex = 0;
            var tempArgs = {{}};
            // Walk through the fields
            for (var i = 0, size = decoder.format.length - 1; i <= size; ++i) {{
                var order = decoder.order_map[orderIndex];
                var currentType = decoder.format[typeIndex];
                if (isNaN(parseInt(currentType))) {{
                    // This field is not an array check the type and add it to the args
                    tempArgs[orderIndex] = t[memberIndex];
                    memberIndex++;
                }} else {{
                    // This field is part of an array, need to find the length of the array
                    var arraySize = "";
                    var newArray = [];
                    while (!isNaN(decoder.format[typeIndex])) {{
                        arraySize = arraySize + decoder.format[typeIndex];
                        typeIndex++;
                    }}
                    // Now that we know how long the array is, create an array with the values
                    for (var j = 0, size = parseInt(arraySize); j < size; ++j) {{
                        newArray.push(t[j + orderIndex]);
                        memberIndex++;
                    }}
                    // Add the array to the args object
                    arraySize = arraySize + decoder.format[typeIndex];
                    currentType = arraySize;
                    tempArgs[orderIndex] = newArray;
                }}
                orderIndex++;
                typeIndex++;
            }}
            // Finally reorder the fields to match the order map
            _.each(t, function (e, i, l) {{
                args[i] = tempArgs[decoder.order_map[i]];
            }});
        }}
        // construct the message object
        try {{
            // args at this point might look like:  {{ '0': 6, '1': 8, '2': 0, '3': 0, '4': 3, '5': 3 }}
            var m = new decoder.type(); // make a new 'empty' instance of the right class,
            m.set(args, false); // associate ordered-field-numbers to names, after construction not during.
        }} catch (e) {{
            throw new Error(
                "Unable to instantiate MAVLink message of type " +
                    decoder.type +
                    " : " +
                    e.message
            );
        }}
        m._signed = sig_ok;
        if (m._signed) {{
            m._link_id = msgbuf[-13];
        }}
        m._msgbuf = msgbuf;
        m._payload = payloadBuf;
        m.crc = receivedChecksum;
        m._header = new mavlink20.header(
            msgId,
            mlen,
            seq,
            srcSystem,
            srcComponent,
            incompat_flags,
            compat_flags
        );
        this.log(m);
        return m;
    }}
}}
"""
    )


def generate_footer(outf, xml):
    mavhead = get_mavhead(xml)
    mavprocessor = get_mavprocessor(xml)

    outf.write(
        f"""
export default {{ {mavhead}, {mavprocessor} }};
"""
    )


# --------------------------------------tests start--------


def isfloat(value):
    try:
        float(value)
        return True
    except ValueError:
        return False


def generate_tests_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(
        outf,
        """
/*
TESTS for MAVLink protocol implementation for node.js (auto-generated by mavgen_javascript.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/
import Long from "long";

import {${MAVHEAD}, ${MAVPROCESSOR}} from "./mavlink2.js";

// mock mav with sysid-42 and componentid=150
let mav = new ${MAVPROCESSOR}(null, 42, 150);

// this uses the above mock by default, but lets us override it before or during tests if desired
let set_mav = function (_mav) {
    // set global mav var from local
    mav = _mav;
};
exports.set_mav = set_mav;

let verbose = 0; // 0 means not verbose, 1 means a bit more, 2 means most verbose
let set_verbose = function (_v) {
    // set global mav var from local
    verbose = _v;
};
exports.set_verbose = set_verbose;

// relevant to how we pass-in the Long object/s to jspack, we'll assume the calling user is smart enough to know that.
var wrap_long = function (someLong) {
    return [someLong.getLowBitsUnsigned(), someLong.getHighBitsUnsigned()];
}


""",
        {
            "FILELIST": ",".join(args),
            "PROTOCOL_MARKER": xml.protocol_marker,
            "crc_extra": xml.crc_extra,
            "WIRE_PROTOCOL_VERSION": ("2.0" if xml.protocol_marker == 253 else "1.0"),
            "MAVHEAD": get_mavhead(xml),
            "MAVPROCESSOR": get_mavprocessor(xml),
            "HEADERLEN": ("10" if xml.protocol_marker == 253 else "6"),
        },
    )


def generate_tests_mavlink_class(outf, msgs, xml):
    print("Generating MAVLink class")

    # Write mapper to enable decoding based on the integer message type
    # t.write(outf, "\n\n${MAVHEAD}.map = {\n", {'MAVHEAD': get_mavhead(xml)});
    for m in msgs:

        outf.write("let test_%s = function () {\n" % (m.name.lower()))

        # var bs = new mavlink20.messages.battery_status(
        outf.write(
            "   if ( verbose == 2 ) console.log('test creating and packing:%s'); \n"
            % (m.name.lower())
        )
        outf.write(
            "   if ( verbose == 1) { process.stdout.write('test creating and packing:"
            + m.name.lower()
            + "          \\r'); }\n"
        )
        outf.write(
            "   var test_%s = new %s.messages.%s(); \n"
            % (m.name.lower(), get_mavhead(xml), m.name.lower())
        )

        idx = 0
        # test data is in same order as ordered_fieldnames
        for f in m.ordered_fieldnames:
            tdata = m.test_data[idx]  # test data
            # tdatatype = m.test_data_types[idx] # type of test data
            fieldtype = m.ordered_fieldtypes[idx]  # type of base field
            # wrap things non-number-like as strings, isnumeric() can't handle negatives, but conveniently none of the test suite uses negatives

            # print('testdata:'+tdata);
            # print('tdatatype:'+tdatatype);
            # print('fieldtype:'+fieldtype);
            # if tdatatype != fieldtype:
            #    sys.exit()

            _isnum = str(tdata).isdigit()
            _isarray = tdata[0] == "["
            _isfloat = isfloat(tdata)

            # javascript inconveniently considers bits >=128 in quite a lot of data types to be unicode, not binary, so we have to understand
            #  these and create them via Buffers and 'binary' or other whacky-doodle-ness here to be sure we get all the tests to pass.

            # array of chars
            if _isarray and (fieldtype == "char"):
                tdata = "new Buffer.from(" + m.test_data[idx] + ').toString("binary")'
                # binary encoding here is important for bits >= 128
            # array of uint8_t ( like char )
            elif _isarray and ((fieldtype == "uint8_t") or (fieldtype == "int8_t")):
                tdata = "new Buffer.from(" + m.test_data[idx] + ').toString("binary")'
                # binary encoding here is important for bits >= 128
            # float/uint16_t/int16_t/int8_t/double array is apparently simple enough without Buffer wrapper
            elif _isarray and (
                (fieldtype == "float")
                or (fieldtype == "uint16_t")
                or (fieldtype == "int16_t")
                or (fieldtype == "double")
                or (fieldtype == "int32_t")
                or (fieldtype == "uint32_t")
            ):
                tdata = m.test_data[idx]
            # array of other things
            elif _isarray:
                tdata = (
                    "new Buffer.from(" + m.test_data[idx] + ") // generic buffer error?"
                )

            # https://github.com/birchroad/node-jspack/pull/4/commits/9828de064af42ab370009d3eeec7fc11be36b918
            elif fieldtype == "uint64_t":  # unsigned
                tdata = 'wrap_long(Long.fromString("' + m.test_data[idx] + '", true))'
                # create unsigned Long from string, then rearrange Long object into 2x32bit unsigned ready for jspack
            elif fieldtype == "int64_t":  # signed
                tdata = 'wrap_long(Long.fromString("' + m.test_data[idx] + '", false))'
                # same as above, but signed Long
            # special signed handling, to properly
            elif (
                fieldtype == "int8_t"
            ):  # signed fields, we sometimes push raw value/s that exceed the min/max range of signed instead of using the correct sign
                tdata = "(new Int8Array([" + m.test_data[idx] + "]))[0]"
                # basically a cast from unsigned int to signed int without sign bit loss
            # special signed handling, to properly
            elif (
                fieldtype == "int16_t"
            ):  # signed fields, we sometimes push raw value/s that exceed the min/max range of signed instead of using the correct sign
                tdata = "(new Int16Array([" + m.test_data[idx] + "]))[0]"
                # basically a cast from unsigned int to signed int without sign bit loss
            # special signed handling, to properly
            elif (
                fieldtype == "int32_t"
            ):  # signed fields, we sometimes push raw value/s that exceed the min/max range of signed instead of using the correct sign
                tdata = "(new Int32Array([" + m.test_data[idx] + "]))[0]"
                # basically a cast from unsigned int to signed int without sign bit loss

            elif _isfloat:
                tdata = m.test_data[idx]
            elif _isnum:
                tdata = m.test_data[idx]
            else:
                # string
                tdata = '"' + m.test_data[idx] + '"'

            outf.write("      test_%s.%s = %s;" % (m.name.lower(), f, tdata))
            outf.write(" // fieldtype: %s " % (fieldtype))
            outf.write(" isarray: %s \n" % (_isarray))
            idx = idx + 1

        outf.write(" //var t = new Buffer.from([])\n; //%s\n" % (m.name.lower()))
        outf.write(" var t = new Buffer.from(test_%s.pack(mav));\n" % (m.name.lower()))

        outf.write(
            "   return [test_%s,t]; // return an array of unpacked and packed options\n"
            % (m.name.lower())
        )
        outf.write("};\n")
        outf.write(
            "exports.test_%s = test_%s; // expose in module\n"
            % (m.name.lower(), m.name.lower())
        )
        outf.write("\n")

    outf.write(get_mavhead(xml) + """Tests = function(){ \n""")

    for m in msgs:
        outf.write("test_%s();\n" % (m.name.lower()))

    outf.write("};\n")


def generate_tests_footer(outf, xml):
    t.write(
        outf,
        """

// if run as an app, run the tests immediately, but if run as a module don't, require user to call
if (require.main === module) {
   verbose=2;  // 0 is not verbose, 1 is a bit, 2 is more.
   ${MAVHEAD}Tests();
}


/* TESTs for MAVLink protocol handling class */
${MAVPROCESSOR}Tests = function() { ${MAVHEAD}Tests(); }
exports.${MAVPROCESSOR}Tests = ${MAVPROCESSOR}Tests; // expose in module

""",
        {"MAVHEAD": get_mavhead(xml), "MAVPROCESSOR": get_mavprocessor(xml)},
    )


def generate(basename, xml):
    """generate complete javascript implementation"""

    if basename.endswith(".js"):
        filename = basename
    else:
        filename = basename + ".js"

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        m.fielddefaults = []
        if xml[0].little_endian:
            m.fmtstr = "<"
        else:
            m.fmtstr = ">"
        m.native_fmtstr = m.fmtstr

        # we've got instance support in generator, but not in the resultant code, yet.
        m.instance_field = None
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
            if f.instance:
                m.instance_field = f.name

        m.order_map = [0] * len(m.fieldnames)
        m.len_map = [0] * len(m.fieldnames)
        m.array_len_map = [0] * len(m.fieldnames)
        m.test_data = [0] * len(m.fieldnames)
        m.test_data_types = [0] * len(m.fieldnames)

        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])
            m.ordered_fieldtypes[i] = m.ordered_fieldtypes[i]
            m.test_data[i] = str(m.ordered_fields[i].test_value)
            m.test_data_types[i] = str(m.ordered_fields[i].type)
            m.array_len_map[i] = m.ordered_fields[i].array_length

        for i in range(0, len(m.fieldnames)):
            n = m.order_map[i]
            m.len_map[n] = m.fieldlengths[i]

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, filelist, xml[0])
    generate_enums(outf, enums, xml[0])
    generate_message_ids(outf, msgs, xml[0])
    generate_classes(outf, msgs, xml[0])
    generate_mavlink_class(outf, msgs, xml[0])
    generate_footer(outf, xml[0])
    outf.close()
    print("Generated %s OK" % filename)

    testfilename = filename.replace(".js", ".tests.js")
    print("Generating TESTS %s" % testfilename)
    outf = open(testfilename, "w")
    generate_tests_preamble(outf, msgs, filelist, xml[0])
    generate_tests_mavlink_class(outf, msgs, xml[0])
    generate_tests_footer(outf, xml[0])
    outf.close()
    print("Generating TESTS %s" % testfilename)
